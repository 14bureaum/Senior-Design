'use strict';

/**
 * @module types
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Condition = require('../lib/condition');
var Fulfillment = require('../lib/fulfillment');
var BaseSha256 = require('./base-sha256');
var MissingDataError = require('../errors/missing-data-error');
var isInteger = require('../util/is-integer');

var Asn1ThresholdFingerprintContents = require('../schemas/fingerprint').ThresholdFingerprintContents;

var CONDITION = 'condition';
var FULFILLMENT = 'fulfillment';

/**
 * THRESHOLD-SHA-256: Threshold gate condition using SHA-256.
 *
 * Threshold conditions can be used to create m-of-n multi-signature groups.
 *
 * Threshold conditions can represent the AND operator by setting the threshold
 * to equal the number of subconditions (n-of-n) or the OR operator by setting
 * the thresold to one (1-of-n).
 *
 * Since threshold conditions operate on conditions, they can be nested as well
 * which allows the creation of deep threshold trees of public keys.
 *
 * By using Merkle trees, threshold fulfillments do not need to to provide the
 * structure of unfulfilled subtrees. That means only the public keys that are
 * actually used in a fulfillment, will actually appear in the fulfillment,
 * saving space.
 *
 * One way to formally interpret a threshold condition is as a booleanthreshold
 * gate. A tree of threshold conditions forms a boolean threshold circuit.
 *
 * THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the SHA-256 and
 * THRESHOLD feature suites which corresponds to a feature bitmask of 0x09.
 */

var ThresholdSha256 = function (_BaseSha) {
  _inherits(ThresholdSha256, _BaseSha);

  function ThresholdSha256() {
    _classCallCheck(this, ThresholdSha256);

    var _this = _possibleConstructorReturn(this, (ThresholdSha256.__proto__ || Object.getPrototypeOf(ThresholdSha256)).call(this));

    _this.threshold = null;
    _this.subconditions = [];
    return _this;
  }

  /**
   * Add a subcondition (unfulfilled).
   *
   * This can be used to generate a new threshold condition from a set of
   * subconditions or to provide a non-fulfilled subcondition when creating a
   * threshold fulfillment.
   *
   * @param {Condition|String} subcondition Condition object or URI string
   *   representing a new subcondition to be added.
   */


  _createClass(ThresholdSha256, [{
    key: 'addSubcondition',
    value: function addSubcondition(subcondition) {
      if (typeof subcondition === 'string') {
        subcondition = Condition.fromUri(subcondition);
      } else if (!(subcondition instanceof Condition)) {
        throw new Error('Subconditions must be URIs or objects of type Condition');
      }

      this.subconditions.push({
        type: CONDITION,
        body: subcondition
      });
    }

    /**
     * Add a fulfilled subcondition.
     *
     * When constructing a threshold fulfillment, this method allows you to
     * provide a fulfillment for one of the subconditions.
     *
     * Note that you do **not** have to add the subcondition if you're adding the
     * fulfillment. The condition can be calculated from the fulfillment and will
     * be added automatically.
     *
     * @param {Fulfillment|String} subfulfillment Fulfillment object or URI string
     *   representing a new subfulfillment to be added.
     */

  }, {
    key: 'addSubfulfillment',
    value: function addSubfulfillment(subfulfillment) {
      if (typeof subfulfillment === 'string') {
        subfulfillment = Fulfillment.fromUri(subfulfillment);
      } else if (!(subfulfillment instanceof Fulfillment)) {
        throw new Error('Subfulfillments must be URIs or objects of type Fulfillment');
      }

      this.subconditions.push({
        type: FULFILLMENT,
        body: subfulfillment
      });
    }

    /**
     * Set the threshold.
     *
     * Determines the threshold that is used to consider this condition fulfilled.
     * If the number of valid subfulfillments is greater or equal to this number,
     * the threshold condition is considered to be fulfilled.
     *
     * @param {Number} threshold Integer threshold
     */

  }, {
    key: 'setThreshold',
    value: function setThreshold(threshold) {
      if (!isInteger(threshold) || threshold < 1) {
        throw new TypeError('Threshold must be a integer greater than zero, was: ' + threshold);
      }

      this.threshold = threshold;
    }

    /**
     * Get set of used type names.
     *
     * This is a type of condition that can contain subconditions. A complete
     * set of subtypes must contain all types that must be supported in order to
     * validate this fulfillment. Therefore, we need to join the type of this
     * fulfillment with all of the sets of subtypes for each of the subconditions.
     *
     * @return {Number} Complete set of types for this fulfillment.
     */

  }, {
    key: 'getSubtypes',
    value: function getSubtypes() {
      var typeSets = this.subconditions.map(function (x) {
        return Array.from(x.body.getSubtypes()).concat(x.body.getTypeName());
      });

      var subtypes = new Set(Array.prototype.concat.apply([], typeSets));

      // Never include our own type as a subtype. The reason is that we already
      // know that the validating implementation knows how to interpret this type,
      // otherwise it wouldn't be able to verify this fulfillment to begin with.
      subtypes.delete(this.constructor.TYPE_NAME);

      return subtypes;
    }

    /**
     * Comparison function used to pre-sort conditions due to lack of sorting
     * support in our current DER encoder of choice.
     *
     * See: https://github.com/indutny/asn1.js/issues/80
     *
     * @param {Condition} a First condition to compare
     * @param {Condition} b Second condition to compare
     *
     * @private
     */

  }, {
    key: 'getFingerprintContents',


    /**
     * Produce the contents of the condition hash.
     *
     * This function is called internally by the `getCondition` method.
     *
     * @return {Buffer} Encoded contents of fingerprint hash.
     *
     * @private
     */
    value: function getFingerprintContents() {
      return Asn1ThresholdFingerprintContents.encode({
        threshold: this.threshold,
        subconditions: this.subconditions.map(function (x) {
          return x.body instanceof Condition ? x.body : x.body.getCondition();
        }).sort(ThresholdSha256.compareConditions).map(function (x) {
          return x.getAsn1Json();
        })
      });
    }

    /**
     * Calculate the cost of fulfilling this condition.
     *
     * In a threshold condition, the cost consists of the t most expensive
     * subconditions plus n times 32 where t is the threshold and n is the
     * total number of subconditions.
     *
     * @return {Number} Expected maximum cost to fulfill this condition
     * @private
     */

  }, {
    key: 'calculateCost',
    value: function calculateCost() {
      // Calculate length of longest fulfillments
      var subconditions = this.subconditions.map(this.constructor.getSubconditionCost);

      var worstCaseFulfillmentsCost = this.constructor.calculateWorstCaseLength(this.threshold, subconditions);

      if (worstCaseFulfillmentsCost === -Infinity) {
        throw new MissingDataError('Insufficient number of subconditions to meet the threshold');
      }

      return worstCaseFulfillmentsCost + 1024 * subconditions.length;
    }
  }, {
    key: 'parseJson',
    value: function parseJson(json) {
      this.setThreshold(json.threshold);
      if (json.subfulfillments) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = json.subfulfillments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var fulfillmentJson = _step.value;

            this.addSubfulfillment(Fulfillment.fromJson(fulfillmentJson));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      if (json.subconditions) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = json.subconditions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var conditionJson = _step2.value;

            this.addSubcondition(Condition.fromJson(conditionJson));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }, {
    key: 'parseAsn1JsonPayload',
    value: function parseAsn1JsonPayload(json) {
      this.setThreshold(json.subfulfillments.length);
      if (json.subfulfillments) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = json.subfulfillments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var fulfillmentJson = _step3.value;

            this.addSubfulfillment(Fulfillment.fromAsn1Json(fulfillmentJson));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
      if (json.subconditions) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = json.subconditions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var conditionJson = _step4.value;

            this.addSubcondition(Condition.fromAsn1Json(conditionJson));
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    }
  }, {
    key: 'getAsn1JsonPayload',
    value: function getAsn1JsonPayload() {
      var fulfillments = this.subconditions.filter(function (x) {
        return x.type === FULFILLMENT;
      }).sort(function (a, b) {
        return a.body.getCondition().getCost() - b.body.getCondition().getCost();
      });
      var conditions = this.subconditions.filter(function (x) {
        return x.type === CONDITION;
      });

      if (fulfillments.length < this.threshold) {
        throw new Error('Not enough fulfillments');
      }

      var minimalFulfillments = fulfillments.slice(0, this.threshold);

      var remainingConditions = conditions.map(function (x) {
        return x.body;
      }).concat(fulfillments.slice(this.threshold).map(function (x) {
        return x.body.getCondition();
      }));

      return {
        subfulfillments: minimalFulfillments.map(function (x) {
          return x.body;
        }).sort(ThresholdSha256.compareConditions).map(function (x) {
          return x.getAsn1Json();
        }),
        subconditions: remainingConditions.sort(ThresholdSha256.compareConditions).map(function (x) {
          return x.getAsn1Json();
        })
      };
    }

    /**
     * Select the smallest valid set of fulfillments.
     *
     * From a set of fulfillments, selects the smallest combination of
     * fulfillments which meets the given threshold.
     *
     * @param {Number} threshold (Remaining) threshold that must be met.
     * @param {Object[]} fulfillments Set of fulfillments
     * @return {Object[]} Minimal set of fulfillments.
     *
     * @private
     */

  }, {
    key: 'validate',


    /**
     * Check whether this fulfillment meets all validation criteria.
     *
     * This will validate the subfulfillments and verify that there are enough
     * subfulfillments to meet the threshold.
     *
     * @param {Buffer} message Message to validate against.
     * @return {Boolean} Whether this fulfillment is valid.
     */
    value: function validate(message) {
      var fulfillments = this.subconditions.filter(function (cond) {
        return cond.type === FULFILLMENT;
      });

      // Number of fulfilled conditions must meet the threshold
      if (fulfillments.length < this.threshold) {
        throw new Error('Threshold not met');
      }

      // But the set must be minimal, there mustn't be any fulfillments
      // we could take out
      if (fulfillments.length > this.threshold) {
        throw new Error('Fulfillment is not minimal');
      }

      // Ensure all subfulfillments are valid
      return fulfillments.every(function (f) {
        return f.body.validate(message);
      });
    }
  }], [{
    key: 'compareConditions',
    value: function compareConditions(a, b) {
      return Buffer.compare(a.serializeBinary(), b.serializeBinary());
    }
  }, {
    key: 'getSubconditionCost',
    value: function getSubconditionCost(cond) {
      return cond.type === FULFILLMENT ? cond.body.getCondition().getCost() : cond.body.getCost();
    }

    /**
     * Calculate the worst case cost of a set of subconditions.
     *
     * Given a set of costs C and a threshold t, it returns the sum of the largest
     * t elements in C.
     *
     * @param {Number} threshold Threshold that the remaining subconditions have
     *   to meet.
     * @param {Number[]} subconditionCosts Set of subconditions.
     * @return {Number} Maximum cost of a valid, minimal set of fulfillments or
     *   -Infinity if there is no valid set.
     *
     * @private
     */

  }, {
    key: 'calculateWorstCaseLength',
    value: function calculateWorstCaseLength(threshold, subconditionCosts) {
      if (subconditionCosts.length < threshold) {
        return -Infinity;
      }

      return subconditionCosts.sort(function (a, b) {
        return a - b;
      }).slice(-threshold).reduce(function (total, size) {
        return total + size;
      }, 0);
    }
  }, {
    key: 'calculateSmallestValidFulfillmentSet',
    value: function calculateSmallestValidFulfillmentSet(threshold, fulfillments) {
      fulfillments.sort(function (a, b) {
        return b.size - a.size;
      });

      return fulfillments.slice(0, threshold);
    }
  }]);

  return ThresholdSha256;
}(BaseSha256);

ThresholdSha256.TYPE_ID = 2;
ThresholdSha256.TYPE_NAME = 'threshold-sha-256';
ThresholdSha256.TYPE_ASN1_CONDITION = 'thresholdSha256Condition';
ThresholdSha256.TYPE_ASN1_FULFILLMENT = 'thresholdSha256Fulfillment';
ThresholdSha256.TYPE_CATEGORY = 'compound';

// DEPRECATED
ThresholdSha256.prototype.addSubconditionUri = ThresholdSha256.prototype.addSubcondition;
ThresholdSha256.prototype.addSubfulfillmentUri = ThresholdSha256.prototype.addSubfulfillment;

module.exports = ThresholdSha256;