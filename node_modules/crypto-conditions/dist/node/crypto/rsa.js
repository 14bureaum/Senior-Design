'use strict';

/**
 * @module types
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var crypto = require('crypto');
var constants = crypto.constants;
var Pss = require('../crypto/pss');
var pem = require('../util/pem');

/**
 * RSA-PSS using Node crypto module.
 *
 * This class combines Node's native crypto functionality with PSS padding
 * implemented in this library.
 */

var Rsa = function () {
  function Rsa(opts) {
    _classCallCheck(this, Rsa);

    opts = opts || {};

    this.hashAlgorithm = opts.hashAlgorithm || 'sha256';

    this.pss = new Pss({
      hashAlgorithm: this.hashAlgorithm
    });
  }

  /**
   * Get the length in bits of an RSA modulus.
   *
   * @param {Buffer} modulus RSA modulus.
   * @return {Number} Number of bits in RSA modulus.
   */


  _createClass(Rsa, [{
    key: 'getModulusBitLength',
    value: function getModulusBitLength(modulus) {
      var modulusHighByteBitLength = modulus[0].toString(2).length;
      var modulusBitLength = (modulus.length - 1) * 8 + modulusHighByteBitLength;

      return modulusBitLength;
    }

    /**
     * Sign a message using RSA-PSS.
     *
     * @param {String} privateKey PEM-encoded RSA private key.
     * @param {Buffer} message Message to sign.
     * @return {Buffer} RSA signature.
     */

  }, {
    key: 'sign',
    value: function sign(privateKey, message) {
      // Calculate modulus bit length
      var modulus = pem.modulusFromPrivateKey(privateKey);
      var modulusBitLength = this.getModulusBitLength(modulus);

      // Pad message using PSS
      var encodedMessage = this.pss.encode(message, modulusBitLength - 1);

      // OpenSSL expects the message buffer to be the same length (in bytes) as
      // the modulus.
      var paddedMessage = encodedMessage.length < modulus.length ? Buffer.concat([Rsa.ZERO_BYTE, encodedMessage]) : encodedMessage;

      // Sign
      return crypto.privateEncrypt({
        key: privateKey,
        padding: constants.RSA_NO_PADDING
      }, paddedMessage);
    }

    /**
     * Verify a RSA-PSS signature.
     *
     * @param {Buffer} modulus RSA public modulus.
     * @param {Buffer} message Message the signature should correspond to.
     * @param {Buffer} signature RSA signature.
     * @return {Boolean} Whether the signature is valid or not.
     */

  }, {
    key: 'verify',
    value: function verify(modulus, message, signature) {
      // Verify signature
      var publicKey = pem.modulusToPem(modulus);
      var paddedMessage = crypto.publicDecrypt({
        key: publicKey,
        padding: constants.RSA_NO_PADDING
      }, signature);

      // OpenSSL returns a buffer that fits the bitlength of the modulus, but we
      // need this buffer to be just long enough to fit the bitlength of the
      // encodedMessage, which is one bit shorter.
      var modulusBitLength = this.getModulusBitLength(modulus);
      var encodedMessage = modulusBitLength % 8 === 1 ? paddedMessage.slice(1) : paddedMessage;

      // Verify message padding
      return this.pss.verify(message, encodedMessage, modulusBitLength - 1);
    }
  }]);

  return Rsa;
}();

// Used to add a zero for padding


Rsa.ZERO_BYTE = Buffer.from([0]);

module.exports = Rsa;