'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var crypto = require('crypto');
var Mgf1 = require('./mgf1');
var xor = require('../util/xor');

var Pss = function () {
  function Pss(opts) {
    _classCallCheck(this, Pss);

    opts = opts || {};

    this.hashAlgorithm = opts.hashAlgorithm || 'sha256';
    this.hashLength = crypto.createHash(this.hashAlgorithm).digest().length;
    this.saltLength = this.hashLength;
  }

  /**
  * Create padded message for signing.
  *
  * This is an implementation of EMSA-PSS-ENCODE from RFC3447, section 9.1.1.
  *
  * @param {Buffer} message Message to sign.
  * @param {Number} encodedMessageBits Number of bits of the resulting padded
  *   message.
  * @return {Buffer} Padded message of length encodedMessageBits bits
  */


  _createClass(Pss, [{
    key: 'encode',
    value: function encode(message, encodedMessageBits) {
      // Calculate emLen
      var encodedMessageBytes = Math.ceil(encodedMessageBits / 8);
      // Step 2. mHash = Hash(M)
      var messageHash = crypto.createHash(this.hashAlgorithm).update(message).digest();
      // Step 3. If emLen < hLen + sLen + 2, output "encoding error" and stop.
      if (encodedMessageBytes < this.hashLength + this.saltLength + 2) {
        throw new Error('Encoding error: RSA modulus is too small for ' + this.hashAlgorithm);
      }
      // Step 4. Generate a random salt
      var salt = crypto.randomBytes(this.saltLength);

      // Step 5. M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt
      // Step 6. H = Hash(M')
      var hash = crypto.createHash(this.hashAlgorithm).update(Buffer.alloc(8).fill(0)).update(messageHash).update(salt).digest();

      // Step 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
      //         zero octets.
      // Step 8. Let DB = PS || 0x01 || salt
      var dataBlock = Buffer.concat([Buffer.alloc(encodedMessageBytes - this.saltLength - this.hashLength - 2).fill(0), Buffer.from([1]), salt]);

      // Step 9. Let dbMask = MGF(H, emLen - hLen - 1)
      var mgf1 = new Mgf1({ hashAlgorithm: this.hashAlgorithm });
      var dataBlockMask = mgf1.generate(hash, encodedMessageBytes - this.hashLength - 1);

      // Step 10. Let maskedDB = DB \xor dbMask
      var maskedDataBlock = xor(dataBlock, dataBlockMask);

      // Step 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
      //          maskedDB to zero.
      maskedDataBlock[0] &= 0xff >>> encodedMessageBytes * 8 - encodedMessageBits;

      // Step 12. Let EM = maskedDB || H || 0xbc.
      // Step 13. Output EM.
      return Buffer.concat([maskedDataBlock, hash, Buffer.from([0xbc])]);
    }

    /**
     * Verify that a padded message matches a specimen message.
     *
     * Used for RSA signature verification.
     *
     * This is an implementation of EMSA-PSS-VERIFY from RFC3447, section 9.1.2.
     *
     * @param {Buffer} message Message to be verified.
     * @param {Buffer} encodedMessage Padded message to be compared.
     * @param {Number} encodedMessageBits Number of bits in the padded message.
     * @return {Boolean} Verification result.
     */

  }, {
    key: 'verify',
    value: function verify(message, encodedMessage, encodedMessageBits) {
      // Calculate emLen
      var encodedMessageBytes = Math.ceil(encodedMessageBits / 8);
      // Step 2. mHash = Hash(M)
      var messageHash = crypto.createHash(this.hashAlgorithm).update(message).digest();
      // Step 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop.
      if (encodedMessageBytes < this.hashLength + this.saltLength + 2) {
        return false;
      }
      // Step 4. If the rightmost octet of EM does not have hexadecimal value
      //         0xbc, output "inconsistent" and stop.
      if (encodedMessage[encodedMessage.length - 1] !== 0xbc) {
        return false;
      }
      // Step 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
      //         let H be the next hLen octets.
      var dataBlockLength = encodedMessageBytes - this.hashLength - 1;
      var maskedDataBlock = encodedMessage.slice(0, dataBlockLength);
      var hash = encodedMessage.slice(dataBlockLength, dataBlockLength + this.hashLength);
      // Step 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
      //         maskedDB are not all equal to zero, output "inconsistent" and
      //          stop.
      var expectedMask = 0xff >>> encodedMessageBytes * 8 - encodedMessageBits;
      if (maskedDataBlock[0] & ~expectedMask) {
        return false;
      }
      // Step 7. Let dbMask = MGF(H, emLen - hLen - 1).
      var mgf1 = new Mgf1({ hashAlgorithm: this.hashAlgorithm });
      var dataBlockMask = mgf1.generate(hash, encodedMessageBytes - this.hashLength - 1);
      // Step 8. Let DB = maskedDB \xor dbMask.
      var dataBlock = xor(maskedDataBlock, dataBlockMask);
      // Step 9. Set the leftmost 8emLen - emBits bits of the leftmost octet in DB
      //         to zero.
      dataBlock[0] &= expectedMask;
      // Step 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
      //          or if the octet at position emLen - hLen - sLen - 1 (the leftmost
      //          position is "position 1") does not have hexadecimal value 0x01,
      //          output "inconsistent" and stop.
      var prefixLength = encodedMessageBytes - this.hashLength - this.saltLength - 2;
      for (var i = 0; i < prefixLength; i++) {
        if (dataBlock[i] !== 0) {
          return false;
        }
      }
      if (dataBlock[prefixLength] !== 0x01) {
        return false;
      }
      // Step 11. Let salt be the last sLen octets of DB.
      var salt = dataBlock.slice(dataBlock.length - this.saltLength);

      // Step 12. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt
      // Step 13. Let H' = Hash(M'), an octet string of length hLen.
      var reconstructedHash = crypto.createHash(this.hashAlgorithm).update(Buffer.alloc(8).fill(0)).update(messageHash).update(salt).digest();
      // Step 14. If H = H', output "consistent." Otherwise, output "inconsistent."
      return Buffer.compare(hash, reconstructedHash) === 0;
    }
  }]);

  return Pss;
}();

Pss.EMPTY_BUFFER = Buffer.alloc(0);

module.exports = Pss;