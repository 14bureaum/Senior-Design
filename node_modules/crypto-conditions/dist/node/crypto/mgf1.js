'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var crypto = require('crypto');

var Mgf1 = function () {
  function Mgf1(opts) {
    _classCallCheck(this, Mgf1);

    opts = opts || {};

    this.hashAlgorithm = opts.hashAlgorithm || 'sha256';
    this.hashLength = crypto.createHash(this.hashAlgorithm).digest().length;
    this.saltLength = this.hashLength;
  }

  /**
   * Generate MGF1 full domain hash.
   *
   * Implementation of RFC 3447, section B.2.1.
   *
   * @param {Buffer} seed Seed from which mask is generated.
   * @param {Number} maskLength Intended length of the mask in bytes.
   * @return {Buffer} Mask
   */


  _createClass(Mgf1, [{
    key: 'generate',
    value: function generate(seed, maskLength) {
      var result = Buffer.alloc(maskLength);

      var len = Math.ceil(maskLength / this.hashLength);
      for (var i = 0; i < len; i++) {
        var counter = Buffer.alloc(4);
        counter.writeInt32BE(i, 0);

        var hash = crypto.createHash(this.hashAlgorithm).update(seed).update(counter).digest();

        hash.copy(result, i * this.hashLength);
      }

      return result;
    }
  }]);

  return Mgf1;
}();

module.exports = Mgf1;