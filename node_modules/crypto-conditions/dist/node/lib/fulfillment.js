'use strict';

/**
 * @module types
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TypeRegistry = require('./type-registry');
var Condition = require('./condition');
var base64url = require('../util/base64url');
var Asn1Fulfillment = require('../schemas/fulfillment').Fulfillment;

/**
 * Base class for fulfillment types.
 */

var Fulfillment = function () {
  function Fulfillment() {
    _classCallCheck(this, Fulfillment);
  }

  _createClass(Fulfillment, [{
    key: 'getTypeId',


    /**
     * Return the type ID of this fulfillment.
     *
     * @return {Number} Type ID as an integer.
     */
    value: function getTypeId() {
      return this.constructor.TYPE_ID;
    }
  }, {
    key: 'getTypeName',
    value: function getTypeName() {
      return this.constructor.TYPE_NAME;
    }

    /**
     * Return the bitmask of this fulfillment.
     *
     * For simple fulfillment types this is simply the empty set.
     *
     * For compound fulfillments, this returns the set of names of all
     * subfulfillment types, recursively.
     *
     * @return {Set<String>} Set of subtype names.
     */

  }, {
    key: 'getSubtypes',
    value: function getSubtypes() {
      return new Set();
    }

    /**
     * Generate condition corresponding to this fulfillment.
     *
     * An important property of crypto-conditions is that the condition can always
     * be derived from the fulfillment. This makes it very easy to post
     * fulfillments to a system without having to specify which condition the
     * relate to. The system can keep an index of conditions and look up any
     * matching events related to that condition.
     *
     * @return {Condition} Condition corresponding to this fulfillment.
     */

  }, {
    key: 'getCondition',
    value: function getCondition() {
      var condition = new Condition();
      condition.setHash(this.generateHash());
      condition.setTypeId(this.getTypeId());
      condition.setCost(this.calculateCost());
      condition.setSubtypes(this.getSubtypes());
      return condition;
    }

    /**
     * Shorthand for getting condition URI.
     *
     * Stands for getCondition().serializeUri().
     *
     * @return {String} Condition URI.
     */

  }, {
    key: 'getConditionUri',
    value: function getConditionUri() {
      return this.getCondition().serializeUri();
    }

    /**
     * Shorthand for getting condition encoded as binary.
     *
     * Stands for getCondition().serializeBinary().
     *
     * @return {Buffer} Binary encoded condition.
     */

  }, {
    key: 'getConditionBinary',
    value: function getConditionBinary() {
      return this.getCondition().serializeBinary();
    }

    /**
     * Generate the hash of the fulfillment.
     *
     * This method is a stub and will be overridden by subclasses.
     *
     * @return {Buffer} Fingerprint of the condition.
     *
     * @private
     */

  }, {
    key: 'generateHash',
    value: function generateHash() {
      throw new Error('This method should be implemented by a subclass');
    }

    /**
     * Calculate the cost of the fulfillment payload.
     *
     * Each condition type has a standard deterministic formula for estimating the
     * cost of validating the fulfillment. This is an abstract function which will
     * be overridden by each of the types with the actual formula.
     *
     * @return {Number} Cost
     *
     * @private
     */

  }, {
    key: 'calculateCost',
    value: function calculateCost() {
      throw new Error('Condition types must implement calculateCost');
    }
  }, {
    key: 'parseAsn1JsonPayload',
    value: function parseAsn1JsonPayload(json) {
      this.parseJson(json);
    }

    /**
     * Generate the URI form encoding of this fulfillment.
     *
     * Turns the fulfillment into a URI containing only URL-safe characters. This
     * format is convenient for passing around fulfillments in URLs, JSON and
     * other text-based formats.
     *
     * @return {String} Fulfillment as a URI
     */

  }, {
    key: 'serializeUri',
    value: function serializeUri() {
      return base64url.encode(this.serializeBinary());
    }
  }, {
    key: 'getAsn1Json',
    value: function getAsn1Json() {
      return {
        type: this.constructor.TYPE_ASN1_FULFILLMENT,
        value: this.getAsn1JsonPayload()
      };
    }

    /**
     * Serialize fulfillment to a buffer.
     *
     * Encodes the fulfillment as a string of bytes. This is used internally for
     * encoding subfulfillments, but can also be used to passing around
     * fulfillments in a binary protocol for instance.
     *
     * @return {Buffer} Serialized fulfillment
     */

  }, {
    key: 'serializeBinary',
    value: function serializeBinary() {
      var asn1Json = this.getAsn1Json();
      return Asn1Fulfillment.encode(asn1Json);
    }
  }, {
    key: 'serializeBase64Url',
    value: function serializeBase64Url() {
      return base64url.encode(this.serializeBinary());
    }

    /**
     * Validate this fulfillment.
     *
     * This implementation is a stub and will be overridden by the subclasses.
     *
     * @return {Boolean} Validation result
     */

  }, {
    key: 'validate',
    value: function validate() {
      throw new Error('Not implemented');
    }
  }], [{
    key: 'fromUri',

    /**
     * Create a Fulfillment object from a URI.
     *
     * This method will parse a fulfillment URI and construct a corresponding
     * Fulfillment object.
     *
     * @param {String} serializedFulfillment URI representing the fulfillment
     * @return {Fulfillment} Resulting object
     */
    value: function fromUri(serializedFulfillment) {
      if (serializedFulfillment instanceof Fulfillment) {
        return serializedFulfillment;
      } else if (typeof serializedFulfillment !== 'string') {
        throw new TypeError('Serialized fulfillment must be a string');
      }
      var fulfillment = Fulfillment.fromBinary(Buffer.from(serializedFulfillment, 'base64'));

      return fulfillment;
    }

    /**
     * Create a Fulfillment object from a binary blob.
     *
     * This method will parse a stream of binary data and construct a
     * corresponding Fulfillment object.
     *
     * @param {Buffer} data Binary buffer
     * @return {Fulfillment} Resulting object
     */

  }, {
    key: 'fromBinary',
    value: function fromBinary(data) {
      var fulfillmentJson = Asn1Fulfillment.decode(data);
      return Fulfillment.fromAsn1Json(fulfillmentJson);
    }
  }, {
    key: 'fromAsn1Json',
    value: function fromAsn1Json(json) {
      var FulfillmentClass = TypeRegistry.findByAsn1FulfillmentType(json.type).Class;

      var condition = new FulfillmentClass();
      condition.parseAsn1JsonPayload(json.value);

      return condition;
    }
  }, {
    key: 'fromJson',
    value: function fromJson(json) {
      var ConditionClass = TypeRegistry.findByName(json.type).Class;

      var condition = new ConditionClass();
      condition.parseJson(json);

      return condition;
    }
  }]);

  return Fulfillment;
}();

module.exports = Fulfillment;